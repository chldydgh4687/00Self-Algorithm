# Problem


상근이는 오락실에서 바구니를 옮기는 오래된 게임을 한다. 스크린은 N칸으로 나누어져 있다. 스크린의 아래쪽에는 M칸을 차지하는 바구니가 있다. (M<N) 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 M칸을 차지하고 있다.

스크린의 위에서 사과 여러 개가 떨어진다. 각 사과는 N칸중 한 칸의 상단에서 떨어지기 시작하며, 스크린의 바닥에 닿을때까지 직선으로 떨어진다. 한 사과가 바닥에 닿는 즉시, 다른 사과가 떨어지기 시작한다.

바구니가 사과가 떨어지는 칸을 차지하고 있다면, 바구니는 그 사과가 바닥에 닿을 때, 사과를 담을 수 있다. 상근이는 사과를 모두 담으려고 한다. 이때, 바구니의 이동 거리의 최솟값을 구하는 프로그램을 작성하시오.

# Input

첫째 줄에 N과 M이 주어진다. (1 ≤ M < N ≤ 10) 둘째 줄에 떨어지는 사과의 개수 J가 주어진다. (1 ≤ J ≤ 20) 다음 J개 줄에는 사과가 떨어지는 위치가 순서대로 주어진다.

# Output

모든 사과를 담기 위해서 바구니가 이동해야 하는 거리의 최솟값을 출력한다.

# Examples
```
#intput  
5 1 
3  
1
5
3

#ouput
6
```
# My Solution
- 요약 : 바구니 크기 그리고 위치, 사과의 위치를 가지고있어야된다고 판단, 이 후 이 서로의 위치에 따라 바구니의 위치를 이동하면서 count를 재면 이는 곧 거리가 된다.
- 생각의 과정 :
1. 처음에는 크기와 이동하는 횟수에 관점을 둚.
2. 바구니를 배열처럼 보면서 sp, ep 로 시작, 끝을 결정하니 사과의 위치에 따라 변화시키면 된다는 생각이 듦.
3. 이 변화에 따라 sp,ep를 빼고 더하는 횟수는 곧 거리라 생각이 듦.

```c
#include <stdio.h>
int reverse(int p);
int zeros_(int p);
int main(){
    int n; scanf("%d", &n);
    int a,b, sum = 0;
    for(int i = 0; i < n; i++){
        scanf("%d %d", &a, &b);
        a = reverse(a);
        b = reverse(b);
        sum = a + b; sum = reverse(sum);
        printf("%d\n",zeros_(sum));
    }
}
int reverse(int p){
    int r, sum = 0,i = 1, order = p;
    while(order != 0){
        order /= 10;
        i*=10;
    }
    while(p != 0){
        r = p % 10; 
        p /= 10;
        i /= 10;
        sum += r * i;
    }
    return sum;
}
int zeros_(int p){
    while(p % 10 == 0){
        p/=10;
    }
    return p;
}
```
