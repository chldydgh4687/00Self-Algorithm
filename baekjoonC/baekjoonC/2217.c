/*
2217번
https://www.acmicpc.net/problem/2217

N(1≤N≤100,000)개의 로프가 있다. 이 로프를 이용하여
이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길
이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.
하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중
량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때,
각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.
각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어
올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프
를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.
단, 각각의 로프는 한 개씩만 존재한다.

문제 설명
: 다음 모든 로프를 사용할 필용는 없으며와 임의로 몇 개의 로프를 골라서
사용하란말이 핵심이다.

밑의 예시를 설명하자면 2개의 줄이 있으며 해당하는 최대 중량은 10 15 이다.
이러 했을 때 1개일 경우 가장 최대로 들 수 있는 중량은 15에 해당하는 줄이며,
2개 이상부터는 위의 조건에 따라 전체 무게가 분배되어 줄에 걸린다. 예를 들어 
30이라 할 때, 2개이므로 15 15 씩 나누지며 이는 10에 해당하는 줄에 위반하게
된다. 그러므로 가장 작은 중량을 N개 곱한 것이 합쳐진 줄에 해당하는 최대 중량
이다.

풀이
: 정렬을 통하여 내림차순으로 정리한 뒤, 맨 처음에 해당하는 줄이 최대 중량이
된다. 이 후, 2,3...N 개로 늘어날 때마다, 각 마지막배열에 해당하는 최대중량을
줄 개수 경우의 수만큼 곱하여 sum에 축적시키며 반복문이 끝나면, 
해당하는 N줄의 경우의 수의 최대중량이며, 그리드 알고리즘을 통하여
max 보다 클 시 max에 저장시킨다.

오류 :
시간초과 : 정렬을 할 때, 복잡도 때문에, qsort() 함수를 사용해야함.
qsort(정렬할배열or메모리주소, 요소개수, 요소크기, 비교함수)


입력 :
2
10
15
출력 :
20
*/

//#define _CRT_SECURE_NO_WARNINGS
//#include <stdio.h>
//#include <stdlib.h>
//
////비교함수
//int compare(const void* a, const void* b) {
//	int num1 = *(int *)a;
//	//void 포인터를 int 포인터로 변환한 뒤 역참조하여 값을 가져온다.
//	int num2 = *(int *)b;
//
//	if (num1 > num2) return -1;
//	if (num1 < num2) return 1;
//
//	return 0;
//}
//
//int main()
//{
//	int N;
//	scanf("%d", &N);
//
//	int *p = (int*)malloc(N * sizeof(int));
//	int i;
//	for (i = 0; i < N; i++) {
//		scanf("%d", &p[i]);
//	}
//
//	//내림차순 정렬
//	/*int j;
//	int swap;
//	for (i = 0; i < N; i++) {
//		for (j = i + 1; j < N; j++) {
//			if (p[i] < p[j]) {
//				swap = p[j];
//				p[j] = p[i];
//				p[i] = swap;
//			}
//		}
//	}*/
//
//	qsort(p, N, sizeof(int), compare);
//
//	int j;
//	int max = -1, sum=0;
//	for (i = 0; i < N; i++) {
//		for (j = 0; j <= i; j++) {
//			sum += p[i];
//		}
//		if (max < sum) {
//			max = sum;
//		}
//		sum = 0;
//	}
//
//	printf("%d", max);
//	
//}

